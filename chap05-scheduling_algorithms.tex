\chapter{Algoritmos de calendarización de flujos de trabajo}
En el capítulo anterior definimos el problema de calendarizar flujos de trabajo. También se vio que dicho problema pertenece a la categoría de los problemas NP-completos, lo cual significa que la complejidad --o tiempo de ejecución-- para resolver este problema no está acotada por una función polinomial. Por ello, diversos algoritmos se han propuesto para atacar, ya sea de manera total o parcial, el objetivo principal de la calendarización: optimizar el tiempo de ejecución total.

Ahora, con los enfoques de cómputo propuestos en el capítulo 2, se crean diversos algoritmos para diferentes necesidades. Mientras que en los clusters y los grids se asumen que estos recursos son compartidos, los algoritmos de calendarización para estos recursos asumen que los flujos deben ser ejecutados lo más pronto posible, con el fin de hacer que el recurso esté ocupado la mayor parte del tiempo. Por otro lado, el enfoque de nubes permite diseñador de flujos de trabajo elegir entre ejecutar el flujo con todos los recursos a costa de un elevado presupuesto o, minimizar dicho presupuesto tolerando un tiempo de ejecución mayor al mínimo posible.

De acuerdo a Yu et al. \cite{yu2008workflow}, se pueden clasificar los algoritmos de calendarización los algoritmos de flujos de trabajo ejecutados en grids en dos grandes niveles: los algoritmos de Mejor Eesfuerzo y los algoritmos de Calidad en el Servicio\footnote{En la literatura especializada se conoce a este término como \emph{Quality of Service}}. Al primer grupo pertenecen aquellos algoritmos que tratan de minimizar el tiempo total de ejecución\footnote{También conocido como \emph{makespan}}, haciendo uso de todos los recursos disponibles. El segundo grupo, los algoritmos tratan de obtener una calendarización que cumpla las restricciones especificadas como una medida de calidad, con la posibilidad de elegir soluciones que tomen un tiempo de ejecución subóptimo.

A continuación, mostraremos los algoritmos descritos en el trabajo de Yu et al., con los ajustes en notación necesarios para que coincidan con las definiciones de flujo de trabajo establecidas en el capítulo anterior.


\section{Algoritmos de Mejor Esfuerzo}
Este tipo de algoritmos tratan de minimizar algún criterio, que en muchos casos es el tiempo total de ejecución o \emph{makespan}. Cabe aclarar que para los siguientes algoritmos, se asumirá que el grafo del flujo de trabajo tiene una correspondencia biyectiva entre los nodos $mathcal{V}$ y las tareas $mathcal{T}$, es decir, cada nodo del grafo representa una tarea del flujo de trabajo. Las aristas del grafo representan \emph{dependencias entre tareas}.

\subsection{Myopic (miope)}
Este es el más simple de todos los algoritmos. Lo único que hace es buscar un recurso disponible que pueda ejecutar la tarea y asignarle dicha tarea. No toma en cuenta otra característica a optimizar. Este algoritmo fue propuesto por Ramamritham et al. \cite{ramamritham1990efficient}. Ell algoritmo \cite{yu2008workflow} peresentado en estre trabajo se encuentra en la sección \cite{alg:myopic} del Apéndice.

\subsection{Min-min}
El algoritmo min-min está basado en la heurística de terminar las tareas más cortas en el menor tiempo posible. Para ello, hace una estimación del tiempo de ejecución tomando en cuenta el tiempo de preparación de las tareas en los servicios --o recursos-- para tener el tiempo y los archivos necesarios disponibles para el recurso en cuestión. El algoritmo fue presentado por Maheswaran et al. \cite{maheswaran1999dynamic}. El pseudocódigo está descrito en el listado \ref{alg:min-min}.

\subsection{Max-min}
El algoritmo max-min --también propuesto Maheswaran et al. \cite{maheswaran1999dynamic}-- es muy similar al algoritmo min-min. La diferencia radica en que éste calendariza tareas cuyo tiempo mínimo de ejecución es el mayor, de tal modo que se ejecutan las tares más \emph{largas}.

El único cambio que se necesita hacer al algoritmo \ref{alg:min-min} es cambiar la siguiente línea (14):
\[T \leftarrow \arg\min_{t \in \emph{availTasks}}ECT(t,r);\]
por
\[T \leftarrow \arg\max_{t \in \emph{availTasks}}ECT(t,r);\]
Así, el algoritmo modificado puede verse en el pseudocódigo \ref{alg:max-min}.

\subsection{Sufragio}
El algoritmo Sufragio\footnote{También conocido como \emph{Sufferage}} \cite{maheswaran1999dynamic} es una variación del algoritmo Min-min, el cual considera el valor del sufragio para hacer la calendarización. Dicho valor es la diferencia entre el menor tiempo de ejecución para una tarea $t$ sobre un conjunto de recursos disponibles y el segundo menor. Se calendariza a la tarea que tenga el valor del sufragio más alto, por el hecho de que las tareas que son muy sensibles a los cambios de los recursos deben ser calendarizadas primero. El algoritmo se encuentra en la sección \ref{alg:sufferage} del Apéndice.



\section{Algoritmos de Calidad en el Servicio}

\section{Problemas adicionales}

\subsection{Estimación del tiempo}
En los algoritmos vistos en esta seccion, se asume que se conoce el tiempo de ejecucion de una tarea. Sin embargo, en la etapa de diseño de un flujo de trabajo, es complicado conocer la duracion de las tareas, debido a que son muchos los factores que influyen el tiempo total de ejecucion del flujo, como el rendimiento de la plataforma de computo, la cantidad de datos a procesar, el tiempo de comunicacion entre nodos de computo, entre otros. Para mitigar este problema, se han hecho algoritmos basados en series de tiempo que estiman el tiempo de ejecucion de cada una de las tareas de un flujo de trabajo. Estos algoritmos utilizan informacion historica de ejecuciones de flujos de trabajo para realizar las predicciones  \cite{liu2011novel}.